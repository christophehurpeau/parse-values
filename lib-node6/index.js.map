{"version":3,"sources":["../src/index.js"],"names":["parseChoices","quotes","endQuotes","Map","escape","basicSeparators","spaceSeparators","basicOrSpaceSeparators","text","some","separator","includes","firstPotentialSeparators","includeFirstSeparator","textLength","length","choices","endQuote","currentChoice","separators","checkFirstChoice","i","part","substr","chr","push","trim","Error","get","match"],"mappings":"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","file":"index.js","sourcesContent":["const quotes = [\n  '\"',\n  '\\'',\n  '`',\n  '«',\n  '“',\n  '‘',\n];\n\nconst endQuotes = new Map([\n  [quotes[0], quotes[0]],\n  [quotes[1], quotes[1]],\n  [quotes[2], quotes[2]],\n  [quotes[3], '»'],\n  [quotes[4], '”'],\n  [quotes[5], '’'],\n]);\n\nconst escape = '\\\\';\n\nconst basicSeparators = [\n  ',',\n  ';',\n  '\\r',\n  '\\n',\n];\n\nconst spaceSeparators = [\n  ' ',\n];\n\n\nfunction basicOrSpaceSeparators(text) {\n  if (basicSeparators.some(separator => text.includes(separator))) {\n    return basicSeparators;\n  }\n\n  return spaceSeparators;\n}\n\n\nexport default function parseChoices(\n  text: string,\n  firstPotentialSeparators: ?Array<string>,\n  includeFirstSeparator: boolean = false,\n) {\n  const textLength = text.length;\n  const choices = [];\n\n  let endQuote = null;\n  let currentChoice = '';\n\n  let separators = firstPotentialSeparators || basicOrSpaceSeparators(text);\n\n  let checkFirstChoice = !firstPotentialSeparators ? () => null : ((i) => {\n    if (choices.length === 0) {\n      const part = text.substr(i + 1);\n      separators = part.includes(',') || part.includes(';') ? basicSeparators : spaceSeparators;\n    } else {\n      checkFirstChoice = () => null;\n    }\n  });\n\n  for (let i = 0; i < textLength; i++) {\n    const chr = text[i];\n\n    if (!endQuote && separators.includes(chr)) {\n      if (currentChoice.length !== 0) {\n        checkFirstChoice(i);\n\n        if (includeFirstSeparator) currentChoice += chr;\n        choices.push(currentChoice.trim());\n        currentChoice = '';\n      }\n    } else if (endQuote && chr === escape && text[i + 1] === endQuote) {\n      // skip quote\n      i += 1;\n      currentChoice += endQuote;\n    } else if (endQuote && chr === endQuote) {\n      checkFirstChoice(i);\n      choices.push(currentChoice.trim());\n      currentChoice = '';\n      endQuote = null;\n    } else if (!endQuote && quotes.includes(chr)) {\n      if (currentChoice.length !== 0) {\n        throw new Error(`Unexpected ${chr} after ${currentChoice}`);\n      }\n\n      endQuote = endQuotes.get(chr);\n    } else if (currentChoice.length !== 0 || !chr.match(/\\s/)) {\n      currentChoice += chr;\n    }\n  }\n\n  if (currentChoice.length !== 0) {\n    if (endQuote) {\n      throw new Error(`Unexpected end, expecting ${endQuote} after: ${currentChoice}.`);\n    } else {\n      choices.push(currentChoice.trim());\n    }\n  }\n\n  return choices;\n}\n"]}